:sectnums:
:toc: left

:encoding: utf-8
= RISC-V Fast Interrupt: Architectural Tests Plan

A plan for developing the riscv architectural tests for the Fast Interrupt
Extension.

== Introduction

The point of this test plan is to:

* Explain what the RISC-V architectural tests try to achieve, both generally
  and for the fast interrupt architecture in particular.

* Act as a starting point for verification engineers writing
  verification plans. 

Some useful links:

* https://github.com/riscv/riscv-compliance[RISC-V Compliance Github Repo].
** https://github.com/riscv/riscv-compliance/tree/master/doc[Associated Documentation].
* https://github.com/riscv/riscv-fast-interrupt

== Test bench setup and deterministic sequences

The framework for architectural tests is to load a test (binary) and start a hart, 
the hart signals finished, results are extraced from memory and verified against a signature.
Since interrupts can occur asynchronously it is limiting to create deterministic tests for 
different implementations with results that can be compared with SAIL model results.  For example,
with different implementation, a different number of instructions will occur before the pending interrupt bit 
actually gets set.  Depending on the implementation, the execution pc could be a different value than the SAIL model.
The following deterministic test sequences are only designed to test understanding and expected behavior of the CLIC spec.

=== smclic testcases
smclic testcases work for implementations that support m-mode.

generic test pseudo code that is used by most clic tests to stimulate different behavior.  
anything in ALL_CAPS are defines that can be overwritten with -D or at top of test or in model_test.h

[%autofit]
----
/* to stimulate different test behavior using the same generic test pseudo code, 
   individual tests will #define different default values here */ 

#include "model_test.h"
#include "arch_test.h"

current mtvec/mscratch saved (used by arch_test.h so needs to be restored at end of test)

RVMODEL_SETUP_CLIC /* hook to allow implementations to setup their setup required for their specific CLIC implementation (num priv modes, num interrupt levels) */
program mintthresh to RVMODEL_MINTTHRESH
program interrupt1 CLICINTCTL/CLICINTATTR values (based on RVMODEL_INT1_EXCCODE, RVMODEL_INT1_CLICINTCTL, RVMODEL_INT1_CLICINTATTR defines)
program interrupt2 CLICINTCTL/CLICINTATTR values (based on RVMODEL_INT2_EXCCODE, RVMODEL_INT2_CLICINTCTL, RVMODEL_INT2_CLICINTATTR defines)
program interrupt1/2 CLICINTIE (based on RVMODEL_INT1_CLICINTIE, RVMODEL_INT2_CLICINTIE)
RVMODEL_SET_INT1
fence
switch priv_mode to RVMODEL_CLIC_STARTING_PRIV
set mstatus.mie to RVMODEL_MSTATUS_MIE
RVMODEL_WFI
finish /* e.g. if RVMODEL_SET_INT1 is defined to actually not set interrupt1, or interrupt level is 0, or interrupt priv is < current_priv), all signatures would stay default */

m_interrupt_handler1:
  save signatures /* mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl */
  modify mtvec/mtvt to point to interrupt handler2:
  RVMODEL_CLEAR_INT1
  RVMODEL_SET_INT2
  csrrsi t0, mnxti RVMODEL_MNXTI_SIMMED
  set mstatus.mie to RVMODEL_MSTATUS_MIE /* e.g. if RVMODEL_CLEAR_INT1 was defined to actually not clear interrupt1, interrupt1 is still asserted, clint would preempt and jump to interrupt handler2, clic does not */
  modify mepc to jump to finsh
  csrrci t0, mnxti RVMODEL_MNXTI_CIMMED
  save signatures /* mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl */
  mret

m_interrupt_handler2:
  save signatures /* mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl */
  RVMODEL_CLEAR_INT2
  clear mstatus.mpie (so mstatus.mie is 0 after mret)
  mret

finish:
restore mtvec, mscratch for arch_test.h
----

smclic tests TEST PLAN CASES
Defaults:
[%autofit]
----
RVMODEL_INT1_EXCCODE = 0
RVMODEL_INT2_EXCCODE = 3
RVMODEL_INT1_CLICINTIE = 1
RVMODEL_INT2_CLICINTIE = 1
RVMODEL_MSTATUS_MIE = 1
RVMODEL_MNXTI_SIMMED = 0x8
RVMODEL_MNXTI_CIMMED = 0x8
RVMODEL_WFI nop
----
==== nomint-01.S
.Description: expect interrupts will not trigger in m-mode unless mstatus.mie is set
- enable clicintie (default)
- generate interrupt1
- nop
- jump to finish
[%autofit]
----
 RVMODEL_MSTATUS_MIE = 0
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
 RVMODEL_WFI = nop  
----
Coverage
----
mstatus.mie | verify no interrupt occurs in m-mode if mstatus.mie is 0
----
==== nomint-02.S
.Description: expect interrupts will not trigger in m-mode unless clicintie.x is set
- disable clicintie
- generate interrupt1
- enable mstatus.mie
- nop
- jump to finish
[%autofit]
----
 RVMODEL_INT1_CLICINTIE = 0 
 RVMODEL_INT2_CLICINTIE = 0 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
 RVMODEL_WFI = nop  
----
Coverage
----
clicintie[msw]    | verify no msw interrupt occurs if clicintie[msw] is 0
clicintie[mtimer] | verify no mtimer interrupt occurs if clicintie[mtimer] is 0
----
==== nomint-03.S
.Description: expect interrupts will not trigger in m-mode unless clicintctrl.x > mintthresh 
- enable clicintie (default)
- generate interrupt1
- enable mstatus.mie
- nop
- jump to finish
[%autofit]
----
 RVMODEL_MINTTHRESH = RVMODEL_MINTTHRESH_MAX
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
 RVMODEL_WFI = nop  
----
Coverage
----
mintthresh    | verify no msw interrupt occurs if mintthresh is max
----
==== wfi-01.S
.Description: expect wfi to behave like a nop when a single interrupt is pending when mstatus.mie is disabled
- enable clicintie (default)
- generate interrupt1
- wfi
- wakeup
- jump to finish
[%autofit]
----
 RVMODEL_MSTATUS_MIE = 0
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT
----
Coverage
----
mstatus.mie | verify no interrupt occurs in m-mode if mstatus.mie is 0
wfi | verify wakeup/nop occurs with mstatus.mie = 0
wfi | verify wakeup/nop occurs with pending interrupt
----
==== direct-01.S 
.Description: trigger, clear, no retrigger of same interrupt.  Will hang if no interrupt occurs
- enable clicintie (default)
- generate interrupt1
- enable mstatus.mie
- trigger m-mode handler
- clear 1st interrupt
- generate interrupt1 again (ignored)
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT 
 RVMODEL_MINTTHRESH = RVMODEL_MINTTHRESH_MIN
 RVMODEL_WFI = jump_to_self  
----
Coverage
----
mtvec.mode     | verify direct mode is used to handle interrupt
no msip retrigger | verify after mstatus.mie is enabled in interrupt handler, msip will not retrigger because msip intlevel is not > mintstatus
msip trigger | verify RVMODEL_SET_MSW_INT trigger
msip clear   | verify RVMODEL_CLEAR_MSW_INT clear
mcause       | verify machine software interrupt signature
mstatus      | verify mstatus.mie/mpie/mpp signature in interrupt handler and after mret
mtvec        | verify interrupt uses mtvec to calculate pc of interrupt handler (direct)
mepc         | verify mepc location is jump_to_self location
----

==== level-01.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, min level int followed by max level int
- enable clicintie (default)
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- if clicintctrl represents levels, mnxti csrrsi updates mcause.id for 2nd interrupt
- if clicintctrl represents priority, no 2nd interrupt occurs.
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT
 RVMODEL_INT1_CLICINTCTL = RVMODEL_CLICINTCTL_MIN
 RVMODEL_INT2_CLICINTCTL = RVMODEL_CLICINTCTL_MAX  
----
Coverage
----
Interrupt ordering - both interrupts asserted in first interrupt handler
----

==== level-02.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, min level int followed by max level int
- enable clicintie (default)
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- if clicintctrl represents levels, trigger 2nd m-mode handler
- if clicintctrl represents priority, no 2nd interrupt occurs.
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT
 RVMODEL_INT1_CLICINTCTL = RVMODEL_CLICINTCTL_MIN
 RVMODEL_INT2_CLICINTCTL = RVMODEL_CLICINTCTL_MAX
 RVMODEL_MNXTI_SIMMED = 0  
----
Coverage
----
Interrupt ordering - both interrupts asserted in first interrupt handler
----

==== level-03.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, max level int followed by min level int
- enable clicintie (default)
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- if clicintctrl represents levels, 2nd interrupt is lower than current interupt level, no 2nd interrupt occurs.
- if clicintctrl represents priority, 2nd interrupt is same level, no 2nd interrupt occurs. 
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT
 RVMODEL_INT1_CLICINTCTL = RVMODEL_CLICINTCTL_MAX
 RVMODEL_INT2_CLICINTCTL = RVMODEL_CLICINTCTL_MIN  
----
Coverage
----
Interrupt ordering - both interrupts asserted in first interrupt handler
----

==== level-04.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, min level int followed by max level int with max mintthresh setting.
- enable clicintie (default)
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- if clicintctrl represents levels, 2nd interrupt is higher than current interupt level but equal to mintthresh, no 2nd interrupt occurs.
- if clicintctrl represents priority, 2nd interrupt is same level, no 2nd interrupt occurs.
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT
 RVMODEL_INT1_CLICINTCTL = RVMODEL_CLICINTCTL_MIN
 RVMODEL_INT2_CLICINTCTL = RVMODEL_CLICINTCTL_MAX
 RVMODEL_MINTTHRESH_HNDLR1 = RVMODEL_MINTTHRESH_MAX  
----
Coverage
----
Interrupt ordering - both interrupts asserted in first interrupt handler
----

=== ssclic testcases

TEST PLAN CASES
[%autofit]
----
verify interrupt priv delegation | translated privs thru mstatus.mpriv, mstatus.mpp?
verify s-mode interrupt is not handled in m-mode
verify m-mode interrupt is handled in s-mode with mstatus.mie enabled
verify m-mode interrupt is handled in s-mode with mstatus.mie disabled
verify m-mode interrupt can preempt a s-mode interrupt handler
verify write to mtvec.mode updates stvec.mode
verify wfi resumes in m-mode handler if s-mode interrupt occurs 
----

=== smclicshv testcases

TEST PLAN CASES
[%autofit]
----
verify shv auto-clears an edge triggered interrupt 
verify shv interrupt is handled at the correct index in the xtvt table
verify exception is taken when xtvt table is in non-executable region
verify scause.sinhv set with mret returning to s-mode treats mepc as addr in xtvt table
----

=== smclint testcases
Smclint testcases require I, Zicsr, and m-mode interrupts (Smclint).
Since no clint tests are currently available in riscv-arch-test, these tests are created to verify CLINT and that after adding CLIC extension to SAIL that CLINT mode is not broken.
Full coverage of possible interrupts would be difficult because different implementations can choose which are implemented and mip/mie bits can be hardwired to 0.
So the smclint tests only compare up to two interrupts at a time and default to using msip and mtip interrupts.

Below is generic test pseudo code that is used by the smclint tests to stimulate different behavior.  
anything in ALL_CAPS are defines that can be overwritten with -D or at top of test or in model_test.h
[%autofit]
----
/* to stimulate different test behavior using the same generic test pseudo code, 
   individual tests will #define different default values here */ 

#include "model_test.h"
#include "arch_test.h"

current mtvec/mscratch saved (used by arch_test.h so needs to be restored at end of test)
program mie csr RVMODEL_SET_MIE
RVMODEL_SET_INT1
fence
set mstatus.mie to RVMODEL_MSTATUS_MIE
RVMODEL_WFI
jump to finish /* e.g. if RVMODEL_SET_INT1 is defined to actually not set interrupt1, or interrupt level is 0, all signatures would stay default */

m_interrupt_handler1:
  save signatures /* mcause, mstatus, mepc, mtval, mscratch, mip, mie, mideleg */
  modify mtvec to point to interrupt handler2:
  RVMODEL_CLEAR_INT1
  RVMODEL_SET_INT2
  set mstatus.mie to RVMODEL_MSTATUS_MIE /* e.g. if RVMODEL_CLEAR_INT1 was defined to actually not clear interrupt1, interrupt1 is still asserted, clint would preempt and jump to interrupt handler2 */
  modify mepc to jump to finsh
  save signatures /* mcause, mstatus, mepc, mtval, mscratch, mip, mie, mideleg */
  mret

m_interrupt_handler2:
  save signatures /* mcause, mstatus, mepc, mtval, mscratch, mip, mie, mideleg */
  RVMODEL_CLEAR_INT2
  clear mstatus.mpie (so mstatus.mie is 0 after mret)
  mret

finish:
restore mtvec, mscratch for arch_test.h
----

Defaults:
[%autofit]
----
RVMODEL_WFI = wfi
RVMODEL_CLEAR_ALL_INTS = RVMODEL_CLEAR_MSW_INT; RVMODEL_CLEAR_MTIMER_INT
RVMODEL_MSTATUS_MIE = MSTATUS_MIE // 0x8
RVMODEL_SET_MIE = (MIE_MSIE | MIE_MTIE) // 0x8 | 0x80
RVMODEL_CLEAR_MSTATUS_MPIE = MSTATUS_MPIE // 0x80
RVMODEL_MTVEC_MODE = 0
RVMODEL_MSTATUS_MASK = (MSTATUS_MIE | MSTATUS_MPIE | MSTATUS_MPP) // mask signature of mstatus to only compare mie, mpie, mpp bits.
RVMODEL_MIP_MASK = RVMODEL_SET_MIE
RVMODEL_ECALL = <empty>
----

==== msw-01.S
.Description: tests if RVMODEL_SET_MSW_INT is working, hangs in infinite loop otherwise
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = <EMPTY>
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = <EMPTY>
 RVMODEL_WFI = jump_to_self 
----
Coverage
----
msip trigger | verify RVMODEL_SET_MSW_INT trigger
msip clear   | verify RVMODEL_CLEAR_MSW_INT clear
mip.msip     | verify mip signature 0/1
mcause       | verify machine software interrupt signature
mstatus      | verify mstatus.mie/mpie/mpp signature in interrupt handler and after mret
mtvec        | verify interrupt uses mtvec to calculate pc of interrupt handler (direct)
mepc         | verify mepc location is jump_to_self location
----
==== mtimer-01.S
.Description: tests if RVMODEL_SET_MTIMER_INT is working, hangs in infinite loop otherwise
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MTIMER_INT
 RVMODEL_SET_INT2 = <EMPTY>
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MTIMER_INT
 RVMODEL_CLEAR_INT2 = <EMPTY>
 RVMODEL_WFI = jump_to_self  
----
Coverage
----
mtip trigger | verify RVMODEL_SET_MTIMER_INT trigger
mtip clear   | verify RVMODEL_CLEAR_MTIMER_INT clear
mip.mtip     | verify mip signature 0/1
mcause       | verify machine timer interrupt signature
mstatus      | verify mstatus.mie/mpie/mpp signature in interrupt handler and after mret
mtvec        | verify interrupt uses mtvec to calculate pc of interrupt handler (direct)
mepc         | verify mepc location is jump_to_self location
----
==== nomint-01.S
.Description: expect interrupts will not trigger in m-mode unless mstatus.mie is set
- enable mie
- generate interrupts
- nop
- jump to finish
[%autofit]
----
 RVMODEL_MSTATUS_MIE = 0
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
 RVMODEL_WFI = nop  
----
Coverage
----
mstatus.mie | verify no interrupt occurs in m-mode if mstatus.mie is 0
----
==== nomint-02.S
.Description: expect interrupts will not trigger in m-mode unless mie.x is set
- generate interrupts
- enable mstatus.mie
- nop
- jump to finish
[%autofit]
----
 RVMODEL_SET_MIE = 0 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
 RVMODEL_WFI = nop  
----
Coverage
----
mie.msip | verify no msw interrupt occurs if mie.msip is 0
mie.mtip | verify no mtimer interrupt occurs if mie.mtip is 0
----
==== wfi-01.S
.Description: expect wfi to behave like a nop when a single interrupt is pending when mstatus.mie is disabled
- enable mie CSR
- generate interrupts
- wfi
- wakeup
- jump to finish
[%autofit]
----
 RVMODEL_MSTATUS_MIE = 0
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT
----
Coverage
----
mstatus.mie | verify no interrupt occurs in m-mode if mstatus.mie is 0
wfi | verify wakeup/nop occurs with mstatus.mie = 0
wfi | verify wakeup/nop occurs with pending interrupt
----
==== direct-01.S 
.Description: trigger, clear, retrigger same interrupt.
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd m-mode handler
- clear 2nd interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT 
----
Coverage - same as msw-01.S plus
----
mtvec.mode     | verify direct mode is used to handle interrupt
msip retrigger | verify after mstatus.mie is enabled in interrupt handler, msip will retrigger
----
==== direct-02.S 
.Description: trigger, clear, retrigger single interrupt, no 2nd clear. 
Stimulates pending interrupt after setting mstatus.mpie followed by mret
mstatus.mie should be cleared after mret so pending interrupt is not taken
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = <EMPTY> 
----
Coverage - same as msw-01.S plus
----
msip retrigger | verify after mstatus.mie is enabled after mret, msip will retrigger
----
==== vectored-01.S 
.Description: trigger, clear, retrigger single interrupt, vectored-mode.
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger vectored m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd vectored m-mode handler
- clear 2nd interrupt
- set mepc to finish
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT
----
Coverage - same as msw-01.S plus
----
mtvec.mode     | verify vectored mode is used to handle interrupt
msip retrigger | verify after mstatus.mie is enabled in interrupt handler, msip will retrigger
----
==== vectored-02.S 
.Description: trigger, clear, retrigger single interrupt, no 2nd clear. 
Stimulates pending interrupt after setting mstatus.mpie followed by mret, vectored-mode.
mstatus.mie should be cleared after mret so pending interrupt is not taken
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger vectored m-mode handler
- clear 1st interrupt
- generate interrupt
- trigger 2nd vectored m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_INT2 = <EMPTY> 
----
Coverage - same as msw-01.S plus
----
mtvec.mode     | verify vectored mode is used to handle interrupt
msip retrigger | verify after mstatus.mie is enabled after mret, msip will retrigger
----
==== ecall-01.S 
.Description: trigger, clear, set interrupt pending, ecall
Stimulates ecall within an interrupt handler to stimulate mcause.interrupt toggling
mstatus.mie should be cleared after mret so pending interrupt is not taken
- enable mie CSR
- generate interrupt
- enable mstatus.mie
- trigger m-mode vectored interrupt handler
- ecall instruction to trigger (direct) exception handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
- re-trigger interrupt
[%autofit]
----
 RVMODEL_SET_MIE = MIE_MSIE
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = <EMPTY>
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = <EMPTY>
 RVMODEL_ECALL = ecall
----
Coverage - same as msw-01.S plus
----
mtvec.mode           | verify vectored mode is used to handle interrupt
mcause.interrupt 0/1 | verify ecall toggles mcause.interrupt, uses direct exception handler
----
==== level-01.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, mtvec.mode=direct
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- trigger 2nd m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
----
Coverage
----
Interrupt ordering - both interrupts asserted in msw interrupt handler
----
==== level-02.S
.Description: verify interrupt level order, swap 2 interrupt order, mtvec.mode=direct
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger m-mode handler
- generate interrupt 2 (both interrupts now pending)
- set mstatus.mie
- trigger 2nd m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_SET_INT1 = RVMODEL_SET_MTIMER_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT 
----
----
Interrupt ordering - both interrupts asserted in mtimer interrupt handler
----
==== level-03.S
.Description: verify interrupt level order, 2 interrupts asserted in 1st interrupt handler, mtvec.mode=vectored
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger vectored m-mode handler
- generate interrupt 2 (both interrupts now pending)
- set mstatus.mie
- trigger 2nd vectored m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MSW_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MTIMER_INT 
----
Coverage
----
mtvec.mode         | verify vectored mode is used to handle interrupt, signature of higher priority interrupt
Interrupt ordering | both interrupts asserted in msw interrupt handler
----
==== level-04.S
.Description: verify interrupt level order, swap 2 interrupt order, mtvec.mode=vectored
- enable mie CSR
- generate interrupt 1
- enable mstatus.mie
- trigger vectored m-mode handler
- generate interrupt 2 (both interrupts now pending)
- set mstatus.mie
- trigger 2nd vectored m-mode handler
- set mepc to finish
- clear mstatus.mpie
- mret to finish
[%autofit]
----
 RVMODEL_MTVEC_MODE = 1 
 RVMODEL_SET_INT1 = RVMODEL_SET_MTIMER_INT
 RVMODEL_SET_INT2 = RVMODEL_SET_MSW_INT
 RVMODEL_CLEAR_INT1 = <EMPTY>
 RVMODEL_CLEAR_INT2 = RVMODEL_CLEAR_MSW_INT 
----
Coverage
----
mtvec.mode         | verify vectored mode is used to handle interrupt, signature of higher priority interrupt
Interrupt ordering | both interrupts asserted in mtimer interrupt handler
----
=== ssclint testcases
Similar to smclint but adding s-mode interrupt privilege delegation

generic test pseudo code that is used by most clint tests to stimulate different behavior.  
anything in ALL_CAPS are defines that can be overwritten with -D or at top of test or in model_test.h
[%autofit]
----
/* to stimulate different test behavior using the same generic test pseudo code, 
   individual tests will #define different default values here */ 

#include "model_test.h"
#include "arch_test.h"

current mtvec/mscratch saved (used by arch_test.h so needs to be restored at end of test)
program mie csr RVMODEL_SET_MIE
setup delegation
program sie csr RVMODEL_SET_SIE
RVMODEL_SET_MINT1
RVMODEL_SET_MINT2
RVMODEL_SET_SINT1
RVMODEL_SET_SINT2
fence
switch priv_mode to RVMODEL_CLINT_STARTING_PRIV
set mstatus.mie to RVMODEL_MSTATUS_MIE
set SEPC to location_1s
RVMODEL_SWITCH_TO_S_MODE
location1_s:
RVMODEL_WFI
jump done /* e.g. if RVMODEL_SET_INT1 is defined to actually not set interrupt1, or interrupt level is 0, all signatures would stay default */

m_interrupt_handler:
  save m-mode signatures /* mcause, mstatus, mepc, mtval, mscratch, mip, mie, mideleg */
  modify mtvec to point to mtvec_finish:

  if mcause is ECALL, jump to mtvec_finish
  
  RVMODEL_CLEAR_MINT1
  RVMODEL_CLEAR_MINT2
  set MEPC to s_done
  mret

s_interrupt_handler:
  save s-mode signatures /* scause, sstatus, sepc, stval, sscratch, sip, sie */
  modify stvec to point to stvec_finish:

  RVMODEL_CLEAR_SINT1
  RVMODEL_CLEAR_SINT2
  set SEPC to s_done
  sret

stvec_finish:
   save scause signature
s_done:
   ecall
   
mtvec_finish:
   save mcause signature
m_done:
restore mtvec, mscratch for arch_test.h
----

==== nodeleg-01.S 
.Description: Verify when executing in s-mode, the m-mode interrupt will be handled even though mstatus.mie is 0:
- generate m-mode interrupt (ssie) (not delegated to s-mode),
- switch to s-mode (mstatus.mie disabled),
- trigger (m-mode handler),
- clear interrupt,
- return to s-mode,
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = 0
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_MINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_MIP, t0;
----
Coverage
----
mideleg 0         | verify interrupt is handled in m-mode
mstatus.mie=0     | verify m-mode interrupt will occur in s-mode when mstatus.mie=0
mip signature     | verify mip signature
sip signature     | verify since ideleg is 0, sip is not visible
mcause signature  | verify ssie signature
----
==== nodeleg-02.S 
.Description: Verify when executing in s-mode, the m-mode interrupt will be handled (this time mstatus.mie is 1):
- generate m-mode interrupt (stie),
- switch to s-mode (mstatus.mie disabled),
- trigger (m-mode handler),
- clear interrupt,
- return to s-mode,
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = 1
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = SIE_STIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_STIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_MINT1    = LI(t0, SIE_STIE); csrrc x0,CSR_MIE, t0;
----
Coverage
----
mideleg 0         | verify interrupt is handled in m-mode
mstatus.mie=1     | verify m-mode interrupt will occur in s-mode when mstatus.mie=1
mip signature     | verify mip signature
sip signature     | verify since ideleg is 0, sip is not visible
mcause signature  | verify stie signature
----
==== nodelegvec-01.S 
.Description: Verify when executing in s-mode, the vectored m-mode interrupt will be handled even though mstatus.mie is 0:
- generate vectored m-mode interrupt (ssie) (not delegated to s-mode),
- switch to s-mode (mstatus.mie disabled),
- trigger (m-mode handler),
- clear interrupt,
- return to s-mode,
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MTVEC_MODE     = 1 
 RVMODEL_MSTATUS_MIE    = 0
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_MINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_MIP, t0;
----
Coverage
----
mideleg 0         | verify vectored interrupt is handled in m-mode
mstatus.mie=0     | verify vectored m-mode interrupt will occur in s-mode when mstatus.mie=0
mip signature     | verify mip signature
sip signature     | verify since ideleg is 0, sip is not visible
mcause signature  | verify ssie signature
----
==== deleg-01.S 
.Description: Verify when executing in s-mode, an s-mode interrupt will be handled when mstatus.sie is 1:
- generate s-mode interrupt (ssie),
- switch to s-mode,
- trigger (s-mode handler),
- clear interrupt,
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = SIE_SSIE
 RVMODEL_SET_MIE        = 0
 RVMODEL_MIP_MASK       = SIE_SSIE
 RVMODEL_SET_MIDELEG    = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage
----
mideleg           | verify interrupt is handled in s-mode
mstatus.mie=1     | verify s-mode interrupt will occur in s-mode when mstatus.sie=1
mip signature     | verify mip signature
sip signature     | verify since ideleg is set, sip is visible
scause signature  | verify ssie signature
mcause signature  | verify ecall signature
----
==== deleg-02.S 
.Description: Verify when executing in s-mode, an s-mode interrupt will be handled when mstatus.sie is 1:
- generate s-mode interrupt (stie),
- switch to s-mode,
- trigger (s-mode handler),
- clear interrupt,
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = SIE_STIE
 RVMODEL_SET_MIE        = 0
 RVMODEL_MIP_MASK       = SIE_STIE
 RVMODEL_SET_MIDELEG    = SIE_STIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_STIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_STIE); csrrc x0,CSR_SIE, t0;
----
Coverage - same as deleg-01.S except
----
scause signature  | verify stie signature
----
==== delegvec-01.S 
.Description: Verify when executing in s-mode, a vectored s-mode interrupt will be handled when mstatus.sie is 1:
- generate vectored s-mode interrupt (ssie),
- switch to s-mode,
- trigger (s-mode handler),
- clear interrupt,
- ecall back to m-mode
[%autofit]
----
 RVMODEL_STVEC_MODE     = 1 
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = SIE_SSIE
 RVMODEL_SET_MIE        = 0
 RVMODEL_MIP_MASK       = SIE_SSIE
 RVMODEL_SET_MIDELEG    = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage - same as deleg-01.S plus
----
vector signature  | verify s-mode vectored interrupt occurred.
----
==== order-01.S 
.Description: Verify order of 2 s-mode interrupts
- generate 2 s-mode interrupts (ssie, stie),
- switch to s-mode,
- trigger (s-mode handler),
- clear interrupts,
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIE        = 0
 RVMODEL_MIP_MASK       = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = (SIE_SSIE | SIE_STIE)
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
 RVMODEL_SET_SINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT2    = LI(t0, SIE_STIE); csrrc x0,CSR_SIE, t0;
----
Coverage - same as deleg-01.S except
----
scause signature  | verify priority of ssi/sti
----
==== order-02.S 
.Description:
- generate 2 s-mode interrupts (ssie, stie),
- switch to s-mode,
- trigger (s-mode handler),
- only sint1 is cleared,
- re-enable mstatus.sie
- trigger (go to stvec_finish, capture cause signature)
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIE        = 0
 RVMODEL_MIP_MASK       = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = (SIE_SSIE | SIE_STIE)
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
 RVMODEL_SET_SINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
----
Coverage - same as order-01.S except
----
scause 2nd signature | verify sti occurs after ssi cleared and mret
----
==== order-03.S 
.Description:
- generate 2 s-mode interrupts (ssie, stie),
- switch to s-mode,
- trigger (s-mode handler),
- only sint2 is cleared,
- re-enable mstatus.sie
- trigger (go to stvec_finish, capture cause signature)
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIE        = 0
 RVMODEL_MIP_MASK       = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = (SIE_SSIE | SIE_STIE)
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_SET_SINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT2    = LI(t0, SIE_STIE); csrrc x0,CSR_SIE, t0;
----
Coverage - same as order-01.S except  (swapping sint1/sint2 assignment of order-02.s)
----
scause 2nd signature | verify ssi 2nd signature
----
==== order-04.S 
.Description:
- generate 4 m-mode interrupts (msie, mtie, ssie, stie),
- stay in m-mode,
- trigger (m-mode handler),
- only mint1 is cleared,
- do not clear mstatus_mpie so mstatus.mie is re-enabled after mret
- trigger (go to mtvec_finish, capture cause signature)
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_MIE
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = (MIE_MSIE | MIE_MTIE | SIE_SSIE | SIE_STIE)
 RVMODEL_MIP_MASK       = (MIE_MSIE | MIE_MTIE | SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = 0
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_MINT1      = RVMODEL_SET_MSW_INT
 RVMODEL_SET_MINT2      = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_MINT1    = RVMODEL_CLEAR_MSW_INT 
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_SET_SINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_MSTATUS_MPIE = 0
----
Coverage - same as nodeleg-01.S plus
----
mcause 1st signature | verify msi 1st signature
mcause 2nd signature | verify mti 2nd signature
----
==== order-05.S 
.Description:
- generate 3 m-mode interrupts (mtie, ssie, stie),
- stay in m-mode,
- trigger (m-mode handler),
- only mint1 is cleared,
- do not clear mstatus_mpie so mstatus.mie is re-enabled after mret
- trigger (go to mtvec_finish, capture cause signature)
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_MIE
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = (           MIE_MTIE | SIE_SSIE | SIE_STIE)
 RVMODEL_MIP_MASK       = (MIE_MSIE | MIE_MTIE | SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = 0
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_MINT1      = RVMODEL_SET_MSW_INT
 RVMODEL_SET_MINT2      = RVMODEL_SET_MTIMER_INT
 RVMODEL_CLEAR_MINT1    = RVMODEL_CLEAR_MSW_INT
 RVMODEL_CLEAR_MINT2    = RVMODEL_CLEAR_MTIMER_INT
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_SET_SINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_MSTATUS_MPIE = 0
----
Coverage - same as order-04.S except
----
mcause 1st signature | verify mti 1st signature
mcause 2nd signature | verify ssi 2nd signature
mie.msie | verify when 0, it does not affect order of other interrupts
----
==== privorder-01.S 
.Description: Verify m-mode interrupt is handled before s-mode interrupt
- generate 1 m-mode interrupt (ssie) and 1 s-mode interrupt (stie),
- switch to s-mode,
- trigger (m-mode handler),
- clear m-mode interrupt
- return to s-mode
- trigger (s-mode handler)
- clear s-mode interrupt
- return to s-mode
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = SIE_STIE
 RVMODEL_SET_MIE        = SIE_SSIE
 RVMODEL_MIP_MASK       = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = (SIE_STIE)
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_MINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_CLEAR_MINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_MIE, t0;
 RVMODEL_SET_SINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT2    = LI(t0, SIE_STIE); csrrc x0,CSR_SIE, t0;
----
Coverage - same as order-04.S except
----
mcause 1st signature | verify ssi 1st signature
scause 2nd signature | verify sti 2nd signature
----
==== privorder-02.S 
.Description: Verify m-mode vectored interrupt is handled before s-mode interrupt
- generate 1 vectored m-mode interrupt (stie) and 1 direct s-mode interrupt (ssie),
- switch to s-mode,
- trigger (m-mode handler),
- clear m-mode interrupt
- return to s-mode
- trigger (s-mode handler)
- clear s-mode interrupt
- return to s-mode
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MTVEC_MODE     = 1 
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = SIE_SSIE
 RVMODEL_SET_MIE        = SIE_STIE
 RVMODEL_MIP_MASK       = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = (SIE_SSIE)
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
 RVMODEL_SET_MINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_CLEAR_MINT2    = LI(t0, SIE_STIE); csrrc x0,CSR_MIE, t0;
----
Coverage - same as privorder-01.S except
----
m-mode vectored signature | verify m-mode interrupt was vectored
s-mode direct signature   | verify s-mode interrupt was direct
----
==== privorder-03.S 
.Description: Verify m-mode interrupt is handled before s-mode vectored interrupt
- generate 1 direct m-mode interrupt (ssie) and 1 vectored s-mode interrupt (stie),
- switch to s-mode,
- trigger (m-mode handler),
- clear m-mode interrupt
- return to s-mode
- trigger (s-mode handler)
- clear s-mode interrupt
- return to s-mode
- ecall back to m-mode
[%autofit]
----
 RVMODEL_STVEC_MODE     = 1 
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = SIE_STIE
 RVMODEL_SET_MIE        = SIE_SSIE
 RVMODEL_MIP_MASK       = (SIE_SSIE | SIE_STIE)
 RVMODEL_SET_MIDELEG    = (SIE_STIE)
 RVMODEL_SETUP_SIP_INTS = LI(t0, (SIE_SSIE | SIE_STIE)); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_MINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_CLEAR_MINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_MIE, t0;
 RVMODEL_SET_SINT2      = LI(t0, SIE_STIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT2    = LI(t0, SIE_STIE); csrrc x0,CSR_SIE, t0;
----
Coverage - same as privorder-01.S except
----
m-mode direct signature   | verify m-mode interrupt was direct
s-mode vectored signature | verify s-mode interrupt was vectored
----
==== mdisable-01.S 
.Description: Verify m-mode interrupt not taken in m-mode when mstatus.mie is 0
- generate m-mode interrupt (ssie) (not delegated to s-mode),
- stay in m-mode
- wfi
- wakeup
- jump to done
- ecall
[%autofit]
----
 RVMODEL_SWITCH_TO_S_MODE = <EMPTY>
 RVMODEL_MSTATUS_MIE    = 0
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage 
----
mstatus.mie  | verify no m-mode interrupt taken when in m-mode and mstatus.mie is 0
----
==== mdisable-02.S 
.Description: Verify m-mode interrupt not taken in m-mode when mie CSR is 0
- generate m-mode interrupt (ssie) (not delegated to s-mode),
- stay in m-mode
- nop
- wakeup
- jump to done
- ecall
[%autofit]
----
 RVMODEL_WFI            = nop
 RVMODEL_SWITCH_TO_S_MODE = <EMPTY>
 RVMODEL_MSTATUS_MIE    = MSTATUS_MIE
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = 0
 RVMODEL_MIP_MASK       = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage 
----
mie=0  | verify m-mode interrupt not taken when in m-mode and mie is 0
----
==== mdisable-03.S 
.Description: Verify s-mode interrupt not taken in m-mode
- generate s-mode interrupt (ssie)
- stay in m-mode
- wfi
- wakeup
- jump to done
- ecall
[%autofit]
----
 RVMODEL_SWITCH_TO_S_MODE = <EMPTY>
 RVMODEL_SET_SIE        = SIE_SSIE
 RVMODEL_SET_MIE        = SIE_SSIE
 RVMODEL_SET_MIDELEG    = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage 
----
mstatus.sie=1  | verify s-mode interrupt not taken when in m-mode
----
==== sdisable-01.S 
.Description: Verify s-mode interrupt not taken in s-mode when mstatus.sie is 0
- generate s-mode interrupt (ssie)
- switch to s-mode,
- wfi
- wakeup
- jump to done
- ecall back to m-mode
[%autofit]
----
 RVMODEL_MSTATUS_SIE    = 0
 RVMODEL_SET_SIE        = SIE_SSIE
 RVMODEL_SET_MIE        = 0
 RVMODEL_SET_MIDELEG    = SIE_SSIE
 RVMODEL_MIP_MASK       = SIE_STIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage 
----
mstatus.mie=1, mstatus.sie=0  | verify s-mode interrupt not taken when in s-mode when mstatus.sie is 0
----
==== sdisable-02.S 
.Description: Verify s-mode interrupt not taken in s-mode when sie CSR is 0
- generate s-mode interrupt (ssie)
- switch to s-mode,
- nop
- jump to done
- ecall back to m-mode
[%autofit]
----
 RVMODEL_WFI            = nop
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = 0
 RVMODEL_SET_MIE        = 0
 RVMODEL_SET_MIDELEG    = SIE_SSIE
 RVMODEL_MIP_MASK       = SIE_SSIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage 
----
sie=0  | verify s-mode interrupt not taken when in s-mode when sie=0
----
==== sdisable-03.S 
.Description: Verify s-mode interrupt not taken in m-mode when mstatus.sie is 1 (but wfi acts as nop)
- generate s-mode interrupt (ssie)
- wfi
- wakeup
- jump to done
[%autofit]
----
 RVMODEL_SWITCH_TO_S_MODE = <EMPTY>
 RVMODEL_MSTATUS_MIE    = MSTATUS_SIE
 RVMODEL_SET_SIE        = SIE_SSIE
 RVMODEL_SET_MIE        = 0
 RVMODEL_SET_MIDELEG    = SIE_SSIE
 RVMODEL_MIP_MASK       = SIE_STIE
 RVMODEL_SETUP_SIP_INTS = LI(t0, SIE_SSIE); csrrs x0,CSR_MIP, t0;
 RVMODEL_SET_SINT1      = LI(t0, SIE_SSIE); csrrs x0,CSR_SIP, t0;
 RVMODEL_CLEAR_SINT1    = LI(t0, SIE_SSIE); csrrc x0,CSR_SIE, t0;
----
Coverage 
----
mstatus.sie=1, mstatus.sie=1  | verify s-mode interrupt not taken when in m-mode when mstatus.sie is 1
----
=== example of setting MSW and MTIMER interrupts in model_test.h
----
#ifndef RVMODEL_SAIL_MCLINTBASE    
        #define RVMODEL_SAIL_MCLINTBASE 0x02000000
#endif

#ifndef RVMODEL_SAIL_MSIP_OFFSET    
        #define RVMODEL_SAIL_MSIP_OFFSET 0x0
#endif

#ifndef RVMODEL_SAIL_MTIMECMP_OFFSET    
        #define RVMODEL_SAIL_MTIMECMP_OFFSET 0x4000
#endif

#ifndef RVMODEL_SAIL_MTIMECMPH_OFFSET    
        #define RVMODEL_SAIL_MTIMECMPH_OFFSET 0x4004
#endif

#define RVMODEL_SET_MSW_INT                                                           \
    lui t0,      ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MSIP_OFFSET)>> 12);         \
    addi t0, t0, ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MSIP_OFFSET) & 0xFFF);      \
    li t1, 1;                                                                         \
    sw t1, (t0);                                                                      \

#define RVMODEL_CLEAR_MSW_INT                                                         \
    lui t0,      ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MSIP_OFFSET)>> 12);         \
    addi t0, t0, ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MSIP_OFFSET) & 0xFFF);      \
    sw x0, (t0);                                                                      \

#define RVMODEL_SET_MTIMER_INT                                                        \
    lui t0,      ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMP_OFFSET)>> 12);     \
    addi t0, t0, ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMP_OFFSET) & 0xFFF);  \
    sw x0, (t0);                                                                      \
    lui t0,      ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMPH_OFFSET)>> 12);    \
    addi t0, t0, ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMPH_OFFSET) & 0xFFF); \
    sw x0, (t0);                                                                      \

#define RVMODEL_CLEAR_MTIMER_INT                                                      \
    lui t0,      ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMPH_OFFSET)>> 12);    \
    addi t0, t0, ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMPH_OFFSET) & 0xFFF); \
    sw t1, (t0);                                                                      \
    lui t0,      ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMP_OFFSET)>> 12);     \
    addi t0, t0, ((RVMODEL_SAIL_MCLINTBASE + RVMODEL_SAIL_MTIMECMP_OFFSET) & 0xFFF);  \
    sw t1, (t0);                                                                      \
----

=== Coverage

Coverage Holes

* async behavior on pipeline
** Tests only have interrupts occur after mstatus.mie enabled or mret (which sets mstatus.mie to mstatus.mpie)

* limited interrupt types tested
** Tests only compare up-to two interrupts at a time.
** Only msw and mtimer interrupts are used.  MSW and Mtimer interrupts are only asserted and cleared by macros so no actual checking of CLINT msw and mtimer behavior is checked.  
E.g. No mtimer overflow, increment, mtimer/mtimerh rollover is checked.  No external interrupts (SEI, MEI) checked by default. can be overridden with define.

* clicintattr.trig is not testied, i.e., edge vs. level interrupts aren't tested.  interrupt positive-edge vs. negative-edge is not tested.

* xtvec locations 
** Locations aren't randomized, range of table jumps aren't randomized
** Handler address is always in executable memory so no exceptions will occur during interrupt.

* interrupts vs. exceptions
** Only ecall exceptions are used to verify mcause.interrupt toggling.

* wfi holes
** wfi only confirmed to continue/wakeup when mstatus.mie is 0.  Interrupts occur before wfi but do not occur while executing wfi.
** situations where wfi is not required to wake up are not tested 
** wfi resume after interrupt is not checked
** wfi priv-mode traps not checked 

* WARL settings of implementation
** Only legal values are intended to be written to CSRs.  WARL behavior is not checked.

* No u-mode interrupts checked

Coverage Summary

* mtime -> interrupt -> trigger, clear, retrigger
* msip -> interrupt -> trigger, clear, retrigger, enable, disable
* clint -> pending -> trigger, clear, retrigger (both vectored and direct)
* clint -> enable -> combination of xie and xstataus.xie
* clint -> xtvec -> mode (direct vs. vector)
* clint -> ordering -> interrupt (MSI, MTI, SSI, STI)
* clint -> privilege -> delegation -> delegate -> machine/supervisor -> handling/ordering
* clint -> privilege -> pending -> m-mode -> visible, trigger, clear
* clint -> privilege -> pending -> s-mode -> visible, invisible, trigger, clear  (missing sip STI, SEI is read_only in s-mode?)

* clint -> privilege -> enable -> m-mode int, in m-mode -> mie=0 -> not taken
* clint -> privilege -> enable -> m-mode int, in m-mode -> mstatus.mie=0 -> not taken
* clint -> privilege -> enable -> m-mode int, in m-mode -> mie=1 && mstatus.mie=1 -> taken

* clint -> privilege -> enable -> m-mode int, in s-mode -> mie=0 -> not taken
* clint -> privilege -> enable -> m-mode int, in s-mode -> mstatus.mie=0 -> taken
* clint -> privilege -> enable -> m-mode int, in s-mode -> mie=1 && mstatus.mie=1 -> taken

* clint -> privilege -> enable -> s-mode int, in s-mode -> sie=0 -> not taken
* clint -> privilege -> enable -> s-mode int, in s-mode -> mstatus.sie=0 -> not taken
* clint -> privilege -> enable -> s-mode int, in s-mode -> sie=1 && mstatus.sie=1 -> taken

* clint -> privilege -> enable -> s-mode int, in m-mode -> sie=1 && mstatus.sie=1 -> not taken

* clint -> privilege -> xtvec -> m-mode uses mtvec, s-mode uses stvec (direct vs vectored)
* clint -> nested -> m-mode to m-mode
* clint -> nested -> m-mode to s-mode
* clint -> nested -> s-mode to m-mode
* clint -> sequenced interrupts -> m-mode to s-mode

* wfi -> resume -> interrupt -> xie == 1 && mstatus.xie == 0

