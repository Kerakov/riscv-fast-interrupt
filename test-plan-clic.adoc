:sectnums:
:toc: left

:encoding: utf-8
= RISC-V Fast Interrupt: Architectural Tests Plan

A plan for developing the riscv architectural tests for the Fast Interrupt
Extension.

== Introduction

The point of this test plan is to:

* Explain what the RISC-V architectural tests try to achieve, both generally
  and for the fast interrupt architecture in particular.

* Act as a starting point for verification engineers writing
  verification plans. 

Some useful links:

* https://github.com/riscv/riscv-compliance[RISC-V Compliance Github Repo].
** https://github.com/riscv/riscv-compliance/tree/master/doc[Associated Documentation].
* https://github.com/riscv/riscv-fast-interrupt

== Test bench setup and deterministic sequences

The framework for architectural tests is to load a test (binary) and start a hart, 
the hart signals finished, results are extraced from memory and verified against a signature.
Since interrupts can occur asynchronously it is limiting to create deterministic tests for 
different implementations with results that can be compared with SAIL model results.  For example,
with different implementation, a different number of instructions will occur before the pending interrupt bit 
actually gets set.  Depending on the implementation, the execution pc could be a different value than the SAIL model.
The following deterministic test sequences are only designed to test understanding and expected behavior of the CLIC spec.

=== smclic testcases
smclic testcases work for implementations that support m-mode.

generic test pseudo code
----
current mtvec/mscratch saved (used by arch_test.h)
RVMODEL_SET_INT
fence
enable global interrupts
finish (if no interrupts)

interrupt handler1:
save signatures (mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl)
modify mtvec/mtvt to interrupt handler2:
enable interrupts (clint would nest to interrupt handler2, clic does not)
modify mepc to jump to finsh
RVMODEL_CLEAR_INT
RVMODEL_SET_INT2
mret

interrupts still enabled so enter interrupt handler2:
save signatures (mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl)
RVMODEL_CLEAR_INT2
clear previous global interrupts
mret

finish:
restore mtvec, mscratch for arch_test.h
----

[%autofit]
----
 Current  |      CLIC          |->      Current'          Previous
 p/ie/il  | priv level   id    |->    p/ie/il  pc  cde   pp/il/ie epc
 P  0  ?  | nP=P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupts disabled
 P  1  ?  | nP=P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  1  L  | nP=P   0<nL<=L  ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  1  L  | nP=P   L<nL    id  |->    P 0  nL  V   id    P  L  1  pc  # Horizontal interrupt taken

----

m-mode CSRs to check signatures
mstatus
mideleg
mie
mtvec
mtvt
mscratch
mepc
mcause
mtval
mip
mnxti
mintstatus
mintthresh
mscratchcswl

TEST PLAN CASES
[%autofit]
----
trigger, clear, retrigger single interrupt for both vectored/direct program 
verify single interrupt will not trigger in m-mode unless both clicintie and mstatus.mie are set  
exception if handler address is in non-executable memory | NOT COVERED
verify interrupt level order
verify interrupt priority order
verify a higher level interrupt can nest a lower level interrupt handler
verify mintthresh can prevent a higher level interrupt nesting a lower level interrupt handler
verify non-shv edge interrupt is cleared after write instruction to mxnti 
verify edge interrupt pending is not cleared when interrupt source is cleared.
verify level interrupt is cleared when interrupt source is cleared
verify mnxti csr contains vector table entry of next pending interrupt
verify mnxti csr returns 0 when pending interrupt level < mcause.mpil
verify write of mnxti updates mstatus
verify updates to mcause shadow fields update mstatus
verify wfi resumes if interrupt level > intstatus.mil and intthresh.mth mstatus.mie disabled
----

=== ssclic testcases

[%autofit]
----
 Current  |      CLIC          |->      Current'          Previous
 p/ie/il  | priv level   id    |->    p/ie/il  pc  cde   pp/il/ie epc
 P  ?  ?  | nP<P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  0  ?  | nP=P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupts disabled
 P  1  ?  | nP=P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  1  L  | nP=P   0<nL<=L  ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  1  L  | nP=P   L<nL    id  |->    P 0  nL  V   id    P  L  1  pc  # Horizontal interrupt taken
 P  ?  ?  | nP>P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  e  L  | nP>P   0<nL    id  |->   nP 0  nL  V   id    P  L  e  pc  # Vertical interrupt taken
----

Additional m/s-mode CSRs to check signatures
sstatus
sie
stvec
stvt
sscratch
sepc
scause
stval
sip
snxti
sintstatus
sintthresh
sscratchcsw
mscratchcsw (priv mode change)
sscratchcswl

TEST PLAN CASES
[%autofit]
----
verify interrupt priv delegation | translated privs thru mstatus.mpriv, mstatus.mpp?
verify s-mode interrupt is not handled in m-mode
verify m-mode interrupt is handled in s-mode with mstatus.mie
verify m-mode interrupt can nest a s-mode interrupt handler
verify write to mtvec.mode updates stvec.mode
verify wfi resumes in m-mode handler if s-mode interrupt occurs 
----

=== smclicshv testcases

TEST PLAN CASES
[%autofit]
----
verify shv auto-clears an edge triggered interrupt 
verify shv interrupt is handled at the correct index in the xtvt table
verify exception is taken when xtvt table is in non-executable region
verify scause.sinhv set with mret returning to s-mode treats mepc as addr in xtvt table
----

== Coverage Holes

=== async behavior on pipeline

=== only comparing up-to two interrupts at a time

=== exception if handler address is in non-executable memory 

=== situations where wfi is not required to wake up. But could be done by user configuring a timer interrupt.

