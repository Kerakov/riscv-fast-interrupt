:sectnums:
:toc: left

:encoding: utf-8
= RISC-V Fast Interrupt: Architectural Tests Plan

A plan for developing the riscv architectural tests for the Fast Interrupt
Extension.

== Introduction

The point of this test plan is to:

* Explain what the RISC-V architectural tests try to achieve, both generally
  and for the fast interrupt architecture in particular.

* Act as a starting point for verification engineers writing
  verification plans. 

Some useful links:

* https://github.com/riscv/riscv-compliance[RISC-V Compliance Github Repo].
** https://github.com/riscv/riscv-compliance/tree/master/doc[Associated Documentation].
* https://github.com/riscv/riscv-fast-interrupt

== Test bench setup and deterministic sequences

The framework for architectural tests is to load a test (binary) and start a hart, 
the hart signals finished, results are extraced from memory and verified against a signature.
Since interrupts can occur asynchronously it is limiting to create deterministic tests for 
different implementations with results that can be compared with SAIL model results.  For example,
with different implementation, a different number of instructions will occur before the pending interrupt bit 
actually gets set.  Depending on the implementation, the execution pc could be a different value than the SAIL model.
The following deterministic test sequences are only designed to test understanding and expected behavior of the CLIC spec.

=== smclic testcases
smclic testcases work for implementations that support m-mode.

generic test pseudo code that is used by most clic tests to stimulate different behavior.  
anything in ALL_CAPS are defines that can be overwritten with -D or at top of test or in model_test.h
[%autofit]
----
/* to stimulate different test behavior using the same generic test pseudo code, 
   individual tests will #define different default values here */ 

#include "model_test.h"
#include "arch_test.h"

current mtvec/mscratch saved (used by arch_test.h so needs to be restored at end of test)

RVMODEL_SETUP_CLIC /* hook to allow implementations to setup their setup required for their specific CLIC implementation (num priv modes, num interrupt levels) */
program mintthresh to RVMODEL_MINTTHRESH
program interrupt1 CLICINTCTL/CLICINTATTR values (based on RVMODEL_INT1_EXCCODE, RVMODEL_INT1_CLICINTCTL, RVMODEL_INT1_CLICINTATTR defines)
program interrupt2 CLICINTCTL/CLICINTATTR values (based on RVMODEL_INT2_EXCCODE, RVMODEL_INT2_CLICINTCTL, RVMODEL_INT2_CLICINTATTR defines)
program interrupt1/2 CLICINTIE (based on RVMODEL_INT1_CLICINTIE, RVMODEL_INT2_CLICINTIE)
RVMODEL_SET_INT1
fence
switch priv_mode to RVMODEL_CLIC_STARTING_PRIV
enable mstatus.mie
finish /* e.g. if RVMODEL_SET_INT1 is defined to actually not set interrupt1, or interrupt level is 0, or interrupt priv is < current_priv), all signatures would stay default */

m_interrupt_handler1:
  save signatures /* mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl */
  modify mtvec/mtvt to point to interrupt handler2:
  RVMODEL_CLEAR_INT1
  RVMODEL_SET_INT2
  csrrsi t0, mnxti RVMODEL_MNXTI_SIMMED
  set mstatus.mie to RVMODEL_MSTATUS_MIE /* e.g. if RVMODEL_CLEAR_INT1 was defined to actually not clear interrupt1, interrupt1 is still asserted, clint would preempt and jump to interrupt handler2, clic does not */
  modify mepc to jump to finsh
  csrrci t0, mnxti RVMODEL_MNXTI_CIMMED
  save signatures /* mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl */
  mret

m_interrupt_handler2:
  save signatures /* mcause, mstatus, mepc, mtval, mintstatus, mintthresh, mnxti, mscratch, mscratchcsw, mscratchcswl */
  RVMODEL_CLEAR_INT2
  clear mstatus.mpie (so mstatus.mie is 0 after mret)
  mret

finish:
restore mtvec, mscratch for arch_test.h
----

m-mode interrupt behavior
[%autofit]
----
 Current  |      CLIC          |->      Current'          Previous
 p/ie/il  | priv level   id    |->    p/ie/il  pc  cde   pp/il/ie epc
 P  0  ?  | nP=P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupts disabled
 P  1  ?  | nP=P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  1  L  | nP=P   0<nL<=L  ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  1  L  | nP=P   L<nL    id  |->    P 0  nL  V   id    P  L  1  pc  # Horizontal interrupt taken
----

smclic tests TEST PLAN CASES  organize by subfeature (trigger, pending, enable, priority, level, threshold/interrupt ordering)
just care about positive coverage?  negative coverage too?  if x doesn't happen?
Defaults:
[%autofit]
----
RVMODEL_INT1_EXCCODE = 0
RVMODEL_INT2_EXCCODE = 3
RVMODEL_INT1_CLICINTIE = 1
RVMODEL_INT2_CLICINTIE = 1
RVMODEL_MSTATUS_MIE = 1
RVMODEL_MNXTI_SIMMED = 0x8
RVMODEL_MNXTI_CIMMED = 0x8
----
==== clic_no_mint-01.S
Description: verify single interrupt will not trigger in m-mode unless both clicintie and mstatus.mie are set
[%autofit]
----
 RVMODEL_INT1_EXCCODE = RVMODEL_INT2_EXCCODE 
 RVMODEL_INT1_CLICINTCTL = RVMODEL_INT2_CLICINTCTL
 RVMODEL_INT1_CLICINTATTR = RVMODEL_INT2_CLICINTCTL
 RVMODEL_INT1_CLICINTIE = RVMODEL_INT2_CLICINTIE = 0
----
==== clic_no_mint-02.S
Description: verify single interrupt will not trigger in m-mode unless both clicintie and mstatus.mie are set
also verifies mnxti csr returns 0 when pending interrupt level < mcause.mpil
[%autofit]
----
 RVMODEL_INT1_EXCCODE = RVMODEL_INT2_EXCCODE 
 RVMODEL_INT1_CLICINTCTL = RVMODEL_INT2_CLICINTCTL
 RVMODEL_INT1_CLICINTATTR = RVMODEL_INT2_CLICINTCTL
 RVMODEL_INT1_CLICINTIE = RVMODEL_INT2_CLICINTIE = 1
----
==== clic_mint_direct.S 
Description: trigger, clear, retrigger single interrupt
[%autofit]
----
 RVMODEL_INT1_EXCCODE = RVMODEL_INT2_EXCCODE 
 RVMODEL_INT1_CLICINTCTL = RVMODEL_INT2_CLICINTCTL
 RVMODEL_INT1_CLICINTATTR = RVMODEL_INT2_CLICINTCTL
----
==== clic_mint_level-01.S
Description: verify interrupt level order
[%autofit]
----
 RVMODEL_INT1_CLICINTCTL = RVMODEL_MAX_CLICINTCTL
 RVMODEL_INT2_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
----
==== clic_mint_level-02.S
Description: verify interrupt level order, 
also verifies a higher level interrupt can preempt a lower level interrupt handler
[%autofit]
----
 RVMODEL_INT1_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
 RVMODEL_INT2_CLICINTCTL = RVMODEL_MAX_CLICINTCTL
----
==== clic_mint_level-03.S
Description: verify interrupt level order, 
also verifies a higher level interrupt can preempt a lower level interrupt handler
[%autofit]
----
 RVMODEL_INT1_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
 RVMODEL_INT2_CLICINTCTL = RVMODEL_MAX_CLICINTCTL
 RVMODEL_MINTTHRESH = RVMODEL_MIN_CLICINTCTL
----
==== clic_mint_level-04.S
Description: verify interrupt level order, 
verifies MINTTHRESH prevents higher level interrupt preempting a lower level interrupt
[%autofit]
----
 RVMODEL_INT1_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
 RVMODEL_INT2_CLICINTCTL = RVMODEL_MAX_CLICINTCTL
 RVMODEL_MINTTHRESH = RVMODEL_MAX_CLICINTCTL
----
==== clic_mint_priority-01.S
Description: verify interrupt priority order
[%autofit]
----
 RVMODEL_INT1_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
 RVMODEL_INT2_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
----
==== clic_mint_priority-02.S
Description: verify interrupt priority order
[%autofit]
----
 RVMODEL_INT1_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
 RVMODEL_INT2_CLICINTCTL = RVMODEL_MIN_CLICINTCTL
----
==== verify non-shv edge interrupt is cleared after write instruction to mxnti 
==== verify edge interrupt pending is not cleared when interrupt source is cleared.
==== verify level interrupt is cleared when interrupt source is cleared
==== verify mnxti csr contains vector table entry of next pending interrupt
==== verify write of mnxti updates mstatus
==== verify updates to mcause shadow fields update mstatus
==== verify wfi resumes if interrupt level > intstatus.mil and intthresh.mth mstatus.mie disabled
==== verify if edge-triggered interrupt, can just write to clicintip, 
==== verify if level-trigger interrupt, write to clicintip ignored.

=== ssclic testcases

m-mode/s-mode interrupt behavior
[%autofit]
----
 Current  |      CLIC          |->      Current'          Previous
 p/ie/il  | priv level   id    |->    p/ie/il  pc  cde   pp/il/ie epc
 P  ?  ?  | nP<P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  0  ?  | nP=P     ?      ?  |->    - -  -   -   -     -  -  -  -   # Interrupts disabled
 P  1  ?  | nP=P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  1  L  | nP=P   0<nL<=L  ?  |->    - -  -   -   -     -  -  -  -   # Interrupt ignored
 P  1  L  | nP=P   L<nL    id  |->    P 0  nL  V   id    P  L  1  pc  # Horizontal interrupt taken
 P  ?  ?  | nP>P     0      ?  |->    - -  -   -   -     -  -  -  -   # No interrupt
 P  e  L  | nP>P   0<nL    id  |->   nP 0  nL  V   id    P  L  e  pc  # Vertical interrupt taken
----

additional s-mode CSRs signatures saved in interrupt handlers
sstatus
sie
stvec
stvt
sscratch
sepc
scause
stval
sip
snxti
sintstatus
sintthresh
sscratchcsw
mscratchcsw (priv mode change)
sscratchcswl

TEST PLAN CASES
[%autofit]
----
verify interrupt priv delegation | translated privs thru mstatus.mpriv, mstatus.mpp?
verify s-mode interrupt is not handled in m-mode
verify m-mode interrupt is handled in s-mode with mstatus.mie enabled
verify m-mode interrupt is handled in s-mode with mstatus.mie disabled
verify m-mode interrupt can preempt a s-mode interrupt handler
verify write to mtvec.mode updates stvec.mode
verify wfi resumes in m-mode handler if s-mode interrupt occurs 
----

=== smclicshv testcases

TEST PLAN CASES
[%autofit]
----
verify shv auto-clears an edge triggered interrupt 
verify shv interrupt is handled at the correct index in the xtvt table
verify exception is taken when xtvt table is in non-executable region
verify scause.sinhv set with mret returning to s-mode treats mepc as addr in xtvt table
----

== Coverage Holes

=== async behavior on pipeline

=== only comparing up-to two interrupts at a time

=== exception if handler address is in non-executable memory 

=== situations where wfi is not required to wake up. 

